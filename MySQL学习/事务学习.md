# 事务

### 1.并发遇到的问题

- 脏写:一个事务修改另一个事务未提交的修改

	- 场景:本身一条记录中账户余额为1000,第一个事务由于购买物品,账户余额减少为900,第二个事务也是由于购买物品账户再减去100,由于第二个事务读取到了一个事务操作后的结果,所以此时账户余额减少为800,但是刚好第一个事务由于异常然后回滚,数据库中账户余额为800,但是此时只买到1样物品,正确的结果应该为900
- 脏读:读取到了另一个事务未提交的修改的数据
- 不可重复读:在同一个事务中两次数据读取结果不一致
- 幻读:查询结果并不存在的结果,但是插入时却无法插入

### 2. 事务的隔离级别

 - 读未提交:读取到另一个事务修改的未提交的数据,解决脏写的问题
 - 读已提交:读取到另一个事务已经提交的数据,解决了脏读的问题
 - 可重复读:在本次事务中读取到的内容都是相同的,解决了不可重复读的问题
 - 可串行化:解决了幻读的问题

### 3. MVCC

数据在数据库中存储在索引中,每一条记录中都有trx_id列和roll_pointer列,trx_id存储了当前记录是属于哪一个事务,roll_pointer指向了上一个版本的记录在undo日志中的位置

对于读未提交的实现,直接读取记录的最新版本即可
读已提交,需要ReadView概念

每一次查询,都会产生一个ReadView视图,ReadView存在以下内容

	- m_ids:当前活跃事务的id列表
	- max_trx_id:生成ReadView时,要分配给下一个事务的id
	- creator_trx_id:生成ReadView的事务的id
	- min_trx_id:m_ids数组中最小的事务的id

读取的规则,使得在读已提交隔离级别下能够读取到所有已经提交的事务的修改和添加

如果数据版本中trx_id的值比min_trx_id的值小,那么肯定是可以读取
如果trx_id的值比max_trx_id的值还要大,那么肯定不读取数据,因为是在创建ReadView之后才进行的修改
如果实在min_trx_id和max_trx_id的值之间,那么要查看是否在m_ids数组中,如果不存在,那么事务已经提交,可以读取,不过存在,那么事务还没提交,不读取

**每次查询时都会产生一个ReadView,所以有可能在min_trx_id和max_trx_id之前的事务已经提交了**



可重复读

在第一次读取时生成ReadView,之后便不再产生ReadView

MVCC出现的理由

	为了解决脏读,不可重复读的问题,使用MVCC来解决

幻读的概念:

	 mysql 的幻读并非什么读取两次返回结果集不同，而是事务在插入事先检测不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测读获取到的数据如同鬼影一般。

在RR级别下解决幻读的问题:

```text
其实 RR 也是可以避免幻读的，通过对 select 操作手动加 行X锁（SELECT ... FOR UPDATE 这也正是 SERIALIZABLE 隔离级别下会隐式为你做的事情），同时还需要知道，即便当前记录不存在，比如 id = 1 是不存在的，当前事务也会获得一把记录锁（因为InnoDB的行锁锁定的是索引，故记录实体存在与否没关系，存在就加 行X锁，不存在就加 next-key lock间隙X锁），其他事务则无法插入此索引的记录，故杜绝了幻读。
```

对于脏写问题的解决,是当对数据进行修改时,会对该行记录进行加锁,在事务提交之前,其他事务均不能修改该行记录


取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。


当插入数据时,这一行数据不会被加锁,但是如果是在可重复读隔离级别下,这一行数据并不会被读取,但是在插入时同样会导致插入错误,这个便是幻读,查询时没有,但是在插入时却出现了数据



### 4.数据库的锁

#### 行级锁

1. 共享锁:事务成功获取某条记录的共享锁,其他事务同样可以获取该行的共享锁,但是不能获取排他锁
2. 排他锁:事务成功获取某条记录的排他锁,其他事务不能获得该条记录的共享锁和排他锁

#### 表级锁

问题:事务要获得表级别的共享锁或者排他锁时,无法得知该表的记录是否存在共享锁或者排他锁,如何解决该问题

当事务获取列级共享锁或者排他锁时,可以在该表上加上一个**意向共享锁**或者是**意向排他锁**,用于阻塞获取表级锁的事务的进程

- 当只存在意向共享锁时,是可以获取表级的共享锁
- 意向共享锁和意向排他锁时兼容的,只是表明该表中某些列中存在共享锁或者排他锁

### 5.MySQL锁的内容

#### 1.全局锁

 MySQL中虽然存在全局锁,但是比较少用,执行增删改查语句,并不会为该表加上全局锁,但是可以手动给表手动加上表级锁

	- LOCK TABLES t READ：InnoDB存储引擎会对表t加表级别的S锁
	
	- LOCK TABLES t WRITE：InnoDB存储引擎会对表t加表级别的X锁

#### 2. 行级锁

1. 正经记录锁LOCK_REC_NOT_GAP	

	- S型正经记录锁
	- X型正经记录锁

2. gap锁:用于解决幻读

	- 为某条记录加上gap锁,这条记录和其前面一条记录之间不允许插入记录
	- 对于最后不允许在最后一条记录插入数据,在数据页的最后一条虚拟记录加上gap锁

3. Next-Key Locks

	- 锁住某条记录,并且不允许在这条记录前面插入新的记录

4. 插入意向锁(Insert Intention Locks)

	当由于gap锁而导致插入数据的阻塞,此时将在这条记录上加上一个插入意向锁,仅仅是表名要插入这条数据但是被阻塞了而已

5. 隐式锁:在插入时便会产生该锁

	- 聚簇索引,其他查看记录的trx_id项是否为活跃的事务,那么为该记录创建排他锁,
	- 二级索引,先查看二级索引中对该记录所在页修改的最大事务的id,如果这个事务的id对应的事务是不活跃的,那么该条记录对应的事务肯定已经提交了,不然的话,回表重复上面的操作


6. 增删改查获取的锁

- DELETE:获取对这条记录的排他锁的锁定读,其他事务如果要获取该条记录的锁,同样会被阻塞,如果是不获取锁的查询并不会阻塞
- UPDATA:未修改主键时且大小未变,则获得X锁的锁定读,大小发生变化,则先删除,再插入,在插入时自动会获得隐式锁
- INSERT:自动获取隐式锁



# 数据库学习遇到的问题 #

1. 加锁问题,隐式锁什么时候解除
2. 在增删改时会加上什么类型的锁

1. 长事务为什么会导致回滚段快速增大?

2. MDL锁:元数据锁

	当对数据进行增删改查便会获取该表的MDL的读锁
	要对表的结构进行修改,此时会获得MDL写锁
	读锁之间不互斥,但是读写锁直接互斥,所以可以多个客户端同时进行增删改,但是不能在增删改的同时修改表的结构

注意:如果一个客户端获取MDL锁时阻塞了,后面对于DML锁的请求都会被阻塞

如何避免由于获取MDL锁被阻塞而导致的数据库线程在短时间被充满?

某个对数据表结构的更改,导致获取DML锁被阻塞,后面某个请求对该表数据的读取将会被阻塞,如果此时客户端存在重传机制,将会在短时间内将数据库的线程的充满


3. 更新时加锁

	在对数据更新时,会对这条被更新的记录加上锁,直到更新数据的事务提交才释放该锁


解决可能出现的死锁的问题

	- 等待时间达到设置的时间,直到超时
	- 发起死锁检测
	
		死锁检测的原理是构建一个以事务为点、锁为边的有向图，判断有向图是否存在环，存在即有死锁

- 如果解决由于对热点行的更新而导致的死锁问题?

	- 降低并发度,一般不可行
	- 修改MySQL源码,对行的更新顺序进行排序
	- 将热点行用多行存储起来,这样对同一行的更新频率自然降低下来


加锁:

select语句加锁之后也是当前读,updata获取的锁也是当前读


可以使用show processlist 命令，看看当前语句处于什么状态。



